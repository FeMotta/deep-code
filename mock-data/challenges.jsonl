{"title": "Soma de Dois Números","description": "Encontre dois números que somados resultem em um valor específico","difficulty": "Fácil","topics": ["Arrays", "Tabela Hash"],"status": "Concluído", "estimatedTime": "10 minutos", "successRate": 0.85, "updatedAt": 1714348800000, "starterCode": "function twoSum(nums, target) {\n  // Seu código aqui\n}", "solutionCode": "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return null;\n}", "testCases": [{"input": "[2,7,11,15], 9", "output": "[0,1]", "explanation": "nums[0] + nums[1] = 2 + 7 = 9"}, {"input": "[3,2,4], 6", "output": "[1,2]"}, {"input": "[3,3], 6", "output": "[0,1]"}], "constraints": ["2 <= nums.length <= 10^4", "-10^9 <= nums[i] <= 10^9", "-10^9 <= target <= 10^9", "Existe exatamente uma solução válida."], "hints": ["Um método por força bruta poderia ser usar dois loops aninhados, mas isso é muito lento.", "Podemos usar uma tabela hash para procurar complementos em tempo constante."], "timeComplexity": "O(n)", "spaceComplexity": "O(n)"}
{"title": "Parênteses Válidos","description": "Determine se a string de entrada possui parênteses válidos","difficulty": "Médio","topics": ["Pilha", "String"],"status": "Tentado", "estimatedTime": "20 minutos", "successRate": 0.62, "updatedAt": 1714262400000, "starterCode": "function isValid(s) {\n  // Seu código aqui\n}", "solutionCode": "function isValid(s) {\n  const stack = [];\n  const map = {\n    '(': ')',\n    '[': ']',\n    '{': '}'\n  };\n  \n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (map[char]) {\n      stack.push(map[char]);\n    } else if (stack.pop() !== char) {\n      return false;\n    }\n  }\n  \n  return stack.length === 0;\n}", "testCases": [{"input": "\"()\"", "output": "true"}, {"input": "\"()[]{}\"", "output": "true"}, {"input": "\"(]\"", "output": "false"}, {"input": "\"([)]\"", "output": "false"}, {"input": "\"{[]}\"", "output": "true"}], "constraints": ["1 <= s.length <= 10^4", "s consiste apenas de parênteses '()[]{}'"], "hints": ["Uma pilha é útil para manter o controle dos parênteses abertos", "Se encontrar um parêntese de fechamento, o último aberto deve corresponder a ele"], "timeComplexity": "O(n)", "spaceComplexity": "O(n)"}
{"title": "Mesclar K Listas Ordenadas","description": "Combine k listas encadeadas ordenadas em uma única lista ordenada","difficulty": "Difícil","topics": ["Lista Encadeada", "Divisão e Conquista"],"status": "Novo", "estimatedTime": "45 minutos", "successRate": 0.35, "updatedAt": 1714176000000, "starterCode": "/**\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val);\n *     this.next = (next===undefined ? null : next);\n * }\n */\nfunction mergeKLists(lists) {\n  // Seu código aqui\n}", "solutionCode": "/**\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val);\n *     this.next = (next===undefined ? null : next);\n * }\n */\nfunction mergeKLists(lists) {\n  if (!lists || lists.length === 0) return null;\n  \n  return mergeLists(lists, 0, lists.length - 1);\n  \n  function mergeLists(lists, start, end) {\n    if (start === end) return lists[start];\n    \n    const mid = Math.floor((start + end) / 2);\n    const left = mergeLists(lists, start, mid);\n    const right = mergeLists(lists, mid + 1, end);\n    \n    return merge(left, right);\n  }\n  \n  function merge(l1, l2) {\n    const dummy = new ListNode(0);\n    let curr = dummy;\n    \n    while (l1 && l2) {\n      if (l1.val < l2.val) {\n        curr.next = l1;\n        l1 = l1.next;\n      } else {\n        curr.next = l2;\n        l2 = l2.next;\n      }\n      curr = curr.next;\n    }\n    \n    curr.next = l1 || l2;\n    return dummy.next;\n  }\n}", "testCases": [{"input": "[[1,4,5],[1,3,4],[2,6]]", "output": "[1,1,2,3,4,4,5,6]", "explanation": "A combinação das listas [1,4,5], [1,3,4] e [2,6] é [1,1,2,3,4,4,5,6]."}], "constraints": ["k == lists.length", "0 <= k <= 10^4", "0 <= lists[i].length <= 500", "-10^4 <= lists[i][j] <= 10^4", "lists[i] está ordenado em ordem crescente.", "A soma de lists[i].length não excederá 10^4."], "hints": ["Você pode mesclar duas listas por vez, mas seria muito ineficiente para muitas listas.", "Uma abordagem mais eficiente é usar divisão e conquista.", "Alternativamente, você pode usar uma fila de prioridades."], "timeComplexity": "O(N log k), onde N é o número total de nós e k é o número de listas", "spaceComplexity": "O(log k) para a pilha de recursão"}
{"title": "Travessia em Ordem de Nível","description": "Retorne a travessia em ordem de nível dos valores de uma árvore binária como um array","difficulty": "Médio","topics": ["Árvore Binária", "BFS"],"status": "Novo", "estimatedTime": "25 minutos", "successRate": 0.58, "updatedAt": 1714089600000, "starterCode": "/**\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val);\n *     this.left = (left===undefined ? null : left);\n *     this.right = (right===undefined ? null : right);\n * }\n */\nfunction levelOrder(root) {\n  // Seu código aqui\n}", "solutionCode": "/**\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val);\n *     this.left = (left===undefined ? null : left);\n *     this.right = (right===undefined ? null : right);\n * }\n */\nfunction levelOrder(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const queue = [root];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      currentLevel.push(node.val);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(currentLevel);\n  }\n  \n  return result;\n}", "testCases": [{"input": "[3,9,20,null,null,15,7]", "output": "[[3],[9,20],[15,7]]"}, {"input": "[1]", "output": "[[1]]"}, {"input": "[]", "output": "[]"}], "constraints": ["O número de nós na árvore está no intervalo [0, 2000].", "-1000 <= Node.val <= 1000"], "hints": ["Use uma fila para processar os nós em ordem de nível.", "Mantenha o controle de quantos nós existem em cada nível."], "timeComplexity": "O(n)", "spaceComplexity": "O(n)"}
{"title": "Maior Substring Palíndromo","description": "Encontre a maior substring que seja um palíndromo","difficulty": "Médio","topics": ["String", "Programação Dinâmica"],"status": "Tentado", "estimatedTime": "30 minutos", "successRate": 0.45, "updatedAt": 1714003200000, "starterCode": "function longestPalindrome(s) {\n  // Seu código aqui\n}", "solutionCode": "function longestPalindrome(s) {\n  if (!s || s.length < 1) return '';\n  \n  let start = 0;\n  let maxLength = 1;\n  \n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    \n    // Comprimento do palíndromo atual é right - left - 1\n    if (right - left - 1 > maxLength) {\n      maxLength = right - left - 1;\n      start = left + 1;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    // Expansão para palíndromos ímpares, como 'racecar'\n    expandAroundCenter(i, i);\n    // Expansão para palíndromos pares, como 'abba'\n    expandAroundCenter(i, i + 1);\n  }\n  \n  return s.substring(start, start + maxLength);\n}", "testCases": [{"input": "\"babad\"", "output": "\"bab\"", "explanation": "\"aba\" também é uma resposta válida."}, {"input": "\"cbbd\"", "output": "\"bb\""}, {"input": "\"a\"", "output": "\"a\""}, {"input": "\"ac\"", "output": "\"a\""}], "constraints": ["1 <= s.length <= 1000", "s consiste apenas de caracteres alfanuméricos e espaços."], "hints": ["Você pode começar em cada posição da string e expandir para ambos os lados.", "Considere palíndromos de comprimento ímpar (centrados em um caractere) e de comprimento par (centrados entre dois caracteres).", "Uma abordagem de programação dinâmica também é possível."], "timeComplexity": "O(n²)", "spaceComplexity": "O(1)"}
{"title": "Água da Chuva Acumulada","description": "Calcule quanta água pode ser retida após uma chuva","difficulty": "Difícil","topics": ["Arrays", "Dois Ponteiros", "Programação Dinâmica"],"status": "Novo", "estimatedTime": "40 minutos", "successRate": 0.30, "updatedAt": 1713916800000, "starterCode": "function trap(height) {\n  // Seu código aqui\n}", "solutionCode": "function trap(height) {\n  if (height.length === 0) return 0;\n  \n  let left = 0;\n  let right = height.length - 1;\n  let leftMax = height[left];\n  let rightMax = height[right];\n  let result = 0;\n  \n  while (left < right) {\n    if (leftMax < rightMax) {\n      left++;\n      leftMax = Math.max(leftMax, height[left]);\n      result += leftMax - height[left];\n    } else {\n      right--;\n      rightMax = Math.max(rightMax, height[right]);\n      result += rightMax - height[right];\n    }\n  }\n  \n  return result;\n}", "testCases": [{"input": "[0,1,0,2,1,0,1,3,2,1,2,1]", "output": "6", "explanation": "A elevação do terreno é representada pelo array [0,1,0,2,1,0,1,3,2,1,2,1]. Neste caso, 6 unidades de chuva são retidas."}, {"input": "[4,2,0,3,2,5]", "output": "9"}], "constraints": ["n == height.length", "1 <= n <= 2 * 10^4", "0 <= height[i] <= 10^5"], "hints": ["Tente pensar no problema usando duas abordagens: da esquerda para a direita e da direita para a esquerda.", "A água que pode ser retida em cada posição é determinada pela menor altura máxima dos dois lados menos a altura da posição atual."], "timeComplexity": "O(n)", "spaceComplexity": "O(1)"}
{"title": "Conjunto de Subconjuntos","description": "Gere todos os possíveis subconjuntos de um conjunto dado","difficulty": "Médio","topics": ["Arrays", "Backtracking", "Bit Manipulation"],"status": "Novo", "estimatedTime": "35 minutos", "successRate": 0.52, "updatedAt": 1713830400000, "starterCode": "function subsets(nums) {\n  // Seu código aqui\n}", "solutionCode": "function subsets(nums) {\n  const result = [];\n  \n  function backtrack(start, current) {\n    result.push([...current]);\n    \n    for (let i = start; i < nums.length; i++) {\n      current.push(nums[i]);\n      backtrack(i + 1, current);\n      current.pop();\n    }\n  }\n  \n  backtrack(0, []);\n  return result;\n}", "testCases": [{"input": "[1,2,3]", "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"}, {"input": "[0]", "output": "[[],[0]]"}], "constraints": ["1 <= nums.length <= 10", "-10 <= nums[i] <= 10", "Todos os números em nums são únicos."], "hints": ["Você pode resolver isso recursivamente, adicionando ou não cada elemento ao subconjunto atual.", "Outra abordagem é utilizar manipulação de bits, onde cada bit representa se um elemento está presente ou não."], "timeComplexity": "O(n * 2^n)", "spaceComplexity": "O(n * 2^n)"}
{"title": "Sequência de Fibonacci","description": "Calcule o enésimo número na sequência de Fibonacci","difficulty": "Fácil","topics": ["Matemática", "Recursão", "Memorização"],"status": "Novo", "estimatedTime": "15 minutos", "successRate": 0.78, "updatedAt": 1713744000000, "starterCode": "function fib(n) {\n  // Seu código aqui\n}", "solutionCode": "function fib(n) {\n  if (n <= 1) return n;\n  \n  let prev = 0;\n  let curr = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    const temp = curr;\n    curr = prev + curr;\n    prev = temp;\n  }\n  \n  return curr;\n}", "testCases": [{"input": "2", "output": "1"}, {"input": "3", "output": "2"}, {"input": "4", "output": "3"}, {"input": "30", "output": "832040"}], "constraints": ["0 <= n <= 30"], "hints": ["A abordagem recursiva simples leva a muitos cálculos redundantes. Considere memoização.", "Você também pode resolver isso iterativamente, armazenando apenas os dois números anteriores."], "timeComplexity": "O(n)", "spaceComplexity": "O(1)"}
{"title": "Detecção de Ciclo em Lista Encadeada","description": "Determine se uma lista encadeada contém um ciclo","difficulty": "Médio","topics": ["Lista Encadeada", "Dois Ponteiros"],"status": "Novo", "estimatedTime": "25 minutos", "successRate": 0.55, "updatedAt": 1713657600000, "starterCode": "/**\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\nfunction hasCycle(head) {\n  // Seu código aqui\n}", "solutionCode": "/**\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\nfunction hasCycle(head) {\n  if (!head || !head.next) return false;\n  \n  let slow = head;\n  let fast = head;\n  \n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    \n    if (slow === fast) return true;\n  }\n  \n  return false;\n}", "testCases": [{"input": "[3,2,0,-4], pos=1", "output": "true", "explanation": "Existe um ciclo na lista, onde a cauda se conecta ao segundo nó."}, {"input": "[1,2], pos=0", "output": "true", "explanation": "Existe um ciclo na lista, onde a cauda se conecta ao primeiro nó."}, {"input": "[1], pos=-1", "output": "false", "explanation": "Não existe ciclo na lista."}], "constraints": ["O número de nós na lista está no intervalo [0, 10^4]", "-10^5 <= Node.val <= 10^5", "pos é -1 ou um índice válido na lista"], "hints": ["Considere usar dois ponteiros que se movem em velocidades diferentes.", "Se houver um ciclo, eventualmente os ponteiros irão se encontrar."], "timeComplexity": "O(n)", "spaceComplexity": "O(1)"}